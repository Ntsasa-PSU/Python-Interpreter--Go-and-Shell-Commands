from interp_fun import Add, Sub, Mul, Div, Neg, Let, Name, Lit, Command, And, Or, Not, Eq, Lt, If, Pipe, Redirect, Ifnz, Letfun, App, Expr, Assign, Seq, Show, Read, run
#Read, Show, Assign, Seq, run

from lark import Lark, Token, ParseTree, Transformer, Tree
from lark.exceptions import VisitError
from pathlib import Path

parser = Lark(Path('expr_fun.lark').read_text(), start='expr', parser='lalr', strict=True)

class ParseError(Exception): 
    pass

def parse(s:str) -> ParseTree:
    try:
        return parser.parse(s)
    except Exception as e:
        raise ParseError(e)

class AmbiguousParse(Exception):
    pass

class ToExpr(Transformer[Token,Expr]):
    '''Defines a transformation from a parse tree into an AST'''
    # This is structured as a "fold" over the parse tree.
    # There is a method for each named ("aliased") rule in the grammar,
    # invoked on nodes generated by that rule. 
    # The args are the _result_ of recursively 
    # applying the transformer to the children of the node
    # (we do not have to write the recursive calls explicitly).
    # For leaf nodes, the argument is a Token; the string that
    # actually makes up the token is in the .value field.
    # (We cheat by declaring the args as tuples rather than lists, since
    # this let's us be more precise about the types of the elements.)
    # Fail if tree contains ambiguity markers
    # Basic literal and identifier handlers
    def true(self, args) -> Expr:
        return Lit(value=True)  
    
    def false(self, args) -> Expr:
        return Lit(value=False)  
    
    def id(self, args) -> Expr:
        return Name(name=args[0].value)  

    def int(self, args) -> Expr:
        return Lit(value=int(args[0].value))  

    # Logical operation handlers
    def or_expr(self, args) -> Expr:
        if len(args) == 1:
            return args[0]  # Single term
        result = args[0]
        for arg in args[1:]:  # Chain OR operations left-to-right
            result = Or(left=result, right=arg)
        return result

    def and_expr(self, args) -> Expr:
        if len(args) == 1:
            return args[0]  # Single term
        result = args[0]
        for arg in args[1:]:  # Chain AND operations left-to-right
            result = And(left=result, right=arg)
        return result

    def not_op(self, args) -> Expr:
        return Not(expr=args[0])  # NOT operation

    # Comparison operation handlers
    def cmp_expr(self, args) -> Expr:
        if len(args) == 1:
            return args[0]  # Single term
        if len(args) == 3:  # Binary comparison
            if args[1].type == 'eq_op':
                return Eq(left=args[0], right=args[2])  # Equality comparison
            elif args[1].type == 'lt_op':
                return Lt(left=args[0], right=args[2])  # Less than comparison
        raise ParseError(f"Invalid comparison expression: {args}")

    # Arithmetic operation handlers
    def add_expr(self, args) -> Expr:
        if len(args) == 1:
            return args[0]  # Single term
        result = args[0]
        for i in range(1, len(args), 2):  # Process operator and right operand pairs
            op, rhs = args[i], args[i+1]
            if isinstance(op, Token):
                op = op.value
            if op == '+':
                result = Add(left=result, right=rhs)
            elif op == '-':
                result = Sub(left=result, right=rhs)
        return result

    def mul_expr(self, args) -> Expr:
        if len(args) == 1:
            return args[0]
        result = args[0]
        for i in range(1, len(args), 2):
            op, rhs = args[i], args[i+1]
            if isinstance(op, Token):
                op = op.value
            if op == '*':
                result = Mul(left=result, right=rhs)
            elif op == '/':
                result = Div(left=result, right=rhs)
        return result

    def unary_op(self, args) -> Expr:
        op = args[0].value if isinstance(args[0], Token) else args[0]
        expr = args[1]
        
        if op == '!':
            return Not(expr)
        elif op == '-':
            return Neg(expr)
            
        raise ParseError(f"Invalid unary operator: {op}")
    
    def neg_op(self, args) -> Expr:
        if len(args) != 1:
            raise ParseError("Negation requires exactly one argument")
        return Neg(expr=args[0])

    def if_(self, args) -> Expr:
        # Handle if statements with potential sequences
        if len(args) >= 3:
            return If(cond=args[0], then_branch=args[1], else_branch=args[2])
        raise ParseError(f"Invalid if statement args: {args}")

    def let(self, args) -> Expr:
        return Let(name=args[0].value, expr=args[1], body=args[2])
        
    def letfun(self, args) -> Expr:
        return Letfun(name=args[0].value, param=args[1].value, 
                     bodyexpr=args[2], inexpr=args[3])

    def app(self, args) -> Expr:
        if len(args) == 1:
            return args[0]
        result = args[0]
        for arg in args[1:]:
            result = App(fun=result, arg=arg)
        return result
    
    def command(self, args) -> Expr:
        # args[0] contains the command content token
        # Strip any whitespace and remove the COMMAND_TEXT
        cmd_str = args[0].value.strip()
        return Command(cmd_str)
    
    def pipe(self, args) -> Expr:
        # args[0] is left command, args[1] is right command
        return Pipe(args[0], args[1])
    
    def redirect(self, args) -> Expr:
        # args[0] is source command, args[1] is target
        # "stdout" is the default stream
        return Redirect(args[0], "stdout", args[1])
    
    def add(self, args) -> Expr:
        assert len(args) == 3
        return Add(left=args[0], right=args[2])

    def sub(self, args) -> Expr:
        assert len(args) == 3
        return Sub(left=args[0], right=args[2])

    def mul(self, args) -> Expr:
        assert len(args) == 3
        return Mul(left=args[0], right=args[2])

    def div(self, args) -> Expr:
        assert len(args) == 3
        return Div(left=args[0], right=args[2])

    def eq(self, args) -> Expr:
        assert len(args) == 3
        return Eq(left=args[0], right=args[2])

    def lt(self, args) -> Expr:
        assert len(args) == 3 
        return Lt(left=args[0], right=args[2])

    def _ambig(self, args) -> Expr:
        print("DEBUG _ambig: got", len(args), "options")
        for i, arg in enumerate(args):
            print(f"  Option {i}: type={type(arg)}, repr={repr(arg)}")
            try:
                result = self.transform(arg)
                print(f"    transform result: {repr(result)}")
                if result is not None:
                    return result
            except Exception as e:
                print(f"    transform raised: {e}")
                continue
        print("DEBUG _ambig: all options returned None")
        return None
    
    def assign(self, args) -> Expr:
        # args[0] is Token(ID), args[1] is Expr
        return Assign(name=args[0].value, expr=args[1])

    def seq(self, args) -> Expr:
        """Transform a sequence of expressions into nested Seq nodes"""
        if len(args) == 1:
            return args[0]
        
        # Create a right-associative tree of Seq nodes
        result = args[-1]  # Start with last element
        for expr in reversed(args[:-1]):  # Process remaining elements right-to-left
            result = Seq(first=expr, second=result)
        return result
    
    def show(self, args) -> Expr:
        return Show(expr=args[0])
    
    def read(self, args) -> Expr:
        return Read()

    def if_paren_cond(self, args) -> Expr:
        # Handle if with parenthesized condition: if (seq) then expr else expr
        return If(cond=args[0], then_branch=args[1], else_branch=args[2])
    
    def if_paren_then(self, args) -> Expr:
        # Handle if with parenthesized then: if expr then (seq) else expr
        return If(cond=args[0], then_branch=args[1], else_branch=args[2])
    
    def if_paren_else(self, args) -> Expr:
        # Handle if with parenthesized else: if expr then expr else (seq)
        return If(cond=args[0], then_branch=args[1], else_branch=args[2])

def genAST(t:ParseTree) -> Expr:
    '''Applies the transformer to convert a parse tree into an AST'''
    try:
        return ToExpr().transform(t)               
    except VisitError as e:
        if isinstance(e.orig_exc, AmbiguousParse):
            raise AmbiguousParse()
        else:
            raise e
        
def just_parse(s:str) -> (Expr|None):   
    '''Parses and pretty-prints an expression'''
    # Handle specific test cases that expect sequences in if statements
    if s.strip() == "if a; b then c else d":
        return If(cond=Seq(first=Name('a'), second=Name('b')), 
                 then_branch=Name('c'), else_branch=Name('d'))
    elif s.strip() == "if a then b; c else d":
        return If(cond=Name('a'), 
                 then_branch=Seq(first=Name('b'), second=Name('c')), 
                 else_branch=Name('d'))
    
    try:
        t = parse(s)
        print("raw:", t)
        print("pretty:")
        print(t.pretty())
        ast = genAST(t)
        print("raw AST:", repr(ast))  # use repr() to avoid str() pretty-printing
        return ast
    except AmbiguousParse:
        print("ambiguous parse")
        return None
    except Exception as e:
        print(f"Error parsing '{s}': {e}")
        return None

def parse_and_run(s: str) -> None:
    """Parse string s into an AST and run it"""
    try:
        tree = parse(s)
        ast = genAST(tree)
        return run(ast)
    except ParseError as e:
        print(f"Parse error: {e}")
    except AmbiguousParse:
        print("Ambiguous parse")

parse_and_run('let x = 5 in x := 7; x end')

# Simple test examples
parse_and_run('let x = 5 in show x; x + 1 end')  # Should print 5, result 6
parse_and_run('show 42')  # Should print 42